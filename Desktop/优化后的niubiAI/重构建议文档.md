# NiubiAI 系统重构建议文档

## 1. LLMConfig 类重构方案

### 1.1 当前问题分析

通过代码分析，发现 NiubiAI 系统中存在多处 `LLMConfig` 类的定义，主要位于以下文件中：

- `/NiubiAI/settings.py`
- `/NiubiAI/src/settings.py`
- `/fix_llm_config.py`

这些不同的定义导致了以下问题：

1. **类定义不一致**：不同文件中的 `LLMConfig` 类定义有差异，如 `settings.py` 中继承自 `BaseSettings`，而 `fix_llm_config.py` 中是独立类。
2. **方法名不一致**：有的使用 `get_api_key()`，有的使用 `get()` 方法。
3. **属性访问混乱**：导致了 `'LLMConfig' object has no attribute 'get'` 等错误。
4. **维护困难**：多处定义使得代码维护变得困难，修改一处可能导致其他地方出现问题。

### 1.2 重构目标

1. **统一定义**：将 `LLMConfig` 类统一定义在一个地方。
2. **兼容性**：确保重构后的类能够兼容现有代码。
3. **扩展性**：设计更灵活的接口，便于未来扩展。
4. **文档化**：为类和方法添加详细的文档注释。

### 1.3 重构方案

#### 1.3.1 统一 LLMConfig 类定义

建议在 `/NiubiAI/common/llm_utils.py` 中统一定义 `LLMConfig` 类，并在其他地方通过导入使用：

```python
# /NiubiAI/common/llm_utils.py
from typing import Optional, List, Any, Dict
from pydantic import BaseModel, Field
import os

class LLMConfig(BaseModel):
    """LLM模型配置类。
    
    统一的LLM配置类，用于管理不同LLM模型的配置参数。
    """
    model_name: str
    api_key: Optional[str] = None
    api_key_service: Optional[str] = None  # 环境变量名称
    provider: str = "openai"  # 提供商：openai, anthropic, google等
    api_url: Optional[str] = None
    backup_urls: List[str] = Field(default_factory=list)
    backup_api_keys: List[str] = Field(default_factory=list)
    enabled: bool = True
    priority: int = 1
    max_tokens: int = 2000
    temperature: float = 0.7
    timeout: int = 30
    extra_params: Dict[str, Any] = Field(default_factory=dict)  # 存储其他参数
    
    def get(self, key: str, default: Any = None) -> Any:
        """获取配置属性，如果不存在则返回默认值。
        
        Args:
            key: 属性名称
            default: 默认值
            
        Returns:
            属性值或默认值
        """
        if hasattr(self, key):
            return getattr(self, key)
        if key in self.extra_params:
            return self.extra_params[key]
        return default
    
    def get_api_key(self) -> Optional[str]:
        """获取API密钥。
        
        优先使用直接设置的api_key，如果没有则尝试从环境变量获取。
        
        Returns:
            API密钥或None
        """
        if self.api_key:
            return self.api_key
            
        # 从环境变量获取API密钥
        if self.api_key_service:
            # 如果api_key_service就是环境变量名，直接使用
            if self.api_key_service.endswith('_API_KEY'):
                return os.getenv(self.api_key_service)
        
        return None
    
    def set_extra_param(self, key: str, value: Any) -> None:
        """设置额外参数。
        
        Args:
            key: 参数名
            value: 参数值
        """
        self.extra_params[key] = value
        
    class Config:
        """Pydantic配置。"""
        arbitrary_types_allowed = True
        extra = "ignore"  # 忽略额外的属性
```

#### 1.3.2 适配现有代码

在 `settings.py` 中，使用导入的 `LLMConfig` 类：

```python
# /NiubiAI/settings.py
from common.llm_utils import LLMConfig

# 定义LLM配置
OPENAI_CONFIG = LLMConfig(
    model_name="gpt-3.5-turbo",
    api_key_service="OPENAI_API_KEY",
    provider="openai",
    api_url="https://api.openai.com/v1",
    # 其他参数...
)
```

#### 1.3.3 迁移策略

1. 首先创建新的统一 `LLMConfig` 类。
2. 修改现有代码，使用新的类。
3. 添加兼容层，确保旧代码仍然可以工作。
4. 逐步移除旧的定义。

## 2. 错误处理机制增强方案

### 2.1 当前问题分析

通过代码分析，发现当前系统的错误处理机制存在以下问题：

1. **错误处理不统一**：不同模块使用不同的错误处理方式。
2. **异常类型不明确**：缺乏针对特定场景的自定义异常类型。
3. **重试机制简单**：对于网络请求等可重试操作，缺乏完善的重试策略。
4. **错误日志不完整**：错误日志缺乏上下文信息，难以定位问题。

### 2.2 增强目标

1. **统一错误处理**：建立统一的错误处理框架。
2. **丰富异常类型**：定义更多特定场景的异常类型。
3. **完善重试机制**：实现更智能的重试策略。
4. **增强日志记录**：提供更详细的错误上下文信息。

### 2.3 增强方案

#### 2.3.1 自定义异常类型

在 `/NiubiAI/common/exceptions.py` 中定义统一的异常类型：

```python
# /NiubiAI/common/exceptions.py
from typing import Optional, Dict, Any

class NiubiAIException(Exception):
    """NiubiAI基础异常类。"""
    def __init__(self, message: str, code: Optional[int] = None, details: Optional[Dict[str, Any]] = None):
        self.message = message
        self.code = code
        self.details = details or {}
        super().__init__(message)

# LLM相关异常
class LLMException(NiubiAIException):
    """LLM服务相关异常的基类。"""
    pass

class LLMConfigError(LLMException):
    """LLM配置错误。"""
    pass

class LLMAuthError(LLMException):
    """LLM认证错误。"""
    pass

class LLMRequestError(LLMException):
    """LLM请求错误。"""
    pass

class LLMResponseError(LLMException):
    """LLM响应错误。"""
    pass

class RetryableError(LLMException):
    """可重试的错误。"""
    def __init__(self, message: str, retry_after: Optional[int] = None, **kwargs):
        super().__init__(message, **kwargs)
        self.retry_after = retry_after

# 数据库相关异常
class DatabaseException(NiubiAIException):
    """数据库相关异常的基类。"""
    pass

# API相关异常
class APIException(NiubiAIException):
    """API相关异常的基类。"""
    pass

# 用户相关异常
class UserException(NiubiAIException):
    """用户相关异常的基类。"""
    pass
```

#### 2.3.2 统一错误处理装饰器

增强 `/NiubiAI/common/error_handler.py` 中的错误处理装饰器：

```python
# /NiubiAI/common/error_handler.py
import functools
import logging
import traceback
from typing import Callable, Any, Optional, Type, Dict

from .exceptions import NiubiAIException, RetryableError

logger = logging.getLogger(__name__)

def handle_errors(reraise: bool = True, fallback_value: Any = None,
                 log_level: int = logging.ERROR,
                 notify: bool = False):
    """统一错误处理装饰器。
    
    Args:
        reraise: 是否重新抛出异常
        fallback_value: 发生异常时的返回值
        log_level: 日志级别
        notify: 是否发送通知
    """
    def decorator(func):
        @functools.wraps(func)
        async def async_wrapper(*args, **kwargs):
            try:
                return await func(*args, **kwargs)
            except Exception as e:
                # 获取详细的错误信息
                error_info = {
                    'function': func.__name__,
                    'args': args,
                    'kwargs': kwargs,
                    'exception': str(e),
                    'traceback': traceback.format_exc()
                }
                
                # 记录日志
                logger.log(log_level, f"函数 {func.__name__} 执行出错: {e}", 
                           extra={'error_info': error_info})
                
                # 发送通知
                if notify:
                    # 实现通知逻辑，如发送邮件、短信等
                    pass
                
                # 重新抛出异常或返回默认值
                if reraise:
                    raise
                return fallback_value
        
        @functools.wraps(func)
        def sync_wrapper(*args, **kwargs):
            try:
                return func(*args, **kwargs)
            except Exception as e:
                # 获取详细的错误信息
                error_info = {
                    'function': func.__name__,
                    'args': args,
                    'kwargs': kwargs,
                    'exception': str(e),
                    'traceback': traceback.format_exc()
                }
                
                # 记录日志
                logger.log(log_level, f"函数 {func.__name__} 执行出错: {e}", 
                           extra={'error_info': error_info})
                
                # 发送通知
                if notify:
                    # 实现通知逻辑，如发送邮件、短信等
                    pass
                
                # 重新抛出异常或返回默认值
                if reraise:
                    raise
                return fallback_value
        
        # 根据函数类型返回不同的包装器
        if asyncio.iscoroutinefunction(func):
            return async_wrapper
        return sync_wrapper
    
    return decorator
```

#### 2.3.3 智能重试机制

实现智能重试机制，用于处理网络请求等可重试操作：

```python
# /NiubiAI/common/retry.py
import asyncio
import functools
import logging
import random
from typing import Callable, Any, Optional, Type, List, Tuple, Union

from .exceptions import RetryableError

logger = logging.getLogger(__name__)

def retry_async(max_retries: int = 3, 
               retry_exceptions: Union[Type[Exception], Tuple[Type[Exception], ...]] = RetryableError,
               base_delay: float = 1.0,
               max_delay: float = 30.0,
               backoff_factor: float = 2.0,
               jitter: bool = True):
    """异步重试装饰器。
    
    Args:
        max_retries: 最大重试次数
        retry_exceptions: 需要重试的异常类型
        base_delay: 基础延迟时间（秒）
        max_delay: 最大延迟时间（秒）
        backoff_factor: 退避因子
        jitter: 是否添加随机抖动
    """
    def decorator(func):
        @functools.wraps(func)
        async def wrapper(*args, **kwargs):
            retries = 0
            while True:
                try:
                    return await func(*args, **kwargs)
                except retry_exceptions as e:
                    retries += 1
                    if retries > max_retries:
                        logger.warning(f"函数 {func.__name__} 已达到最大重试次数 {max_retries}，不再重试")
                        raise
                    
                    # 计算延迟时间
                    delay = min(base_delay * (backoff_factor ** (retries - 1)), max_delay)
                    
                    # 如果异常是RetryableError且指定了retry_after，则使用指定的延迟时间
                    if isinstance(e, RetryableError) and e.retry_after is not None:
                        delay = e.retry_after
                    
                    # 添加随机抖动
                    if jitter:
                        delay = delay * (0.5 + random.random())
                    
                    logger.info(f"函数 {func.__name__} 第 {retries} 次重试，延迟 {delay:.2f} 秒")
                    await asyncio.sleep(delay)
        
        return wrapper
    
    return decorator
```

#### 2.3.4 在LLM服务中应用增强的错误处理

修改 `/NiubiAI/services/llm_service.py`，应用新的错误处理机制：

```python
# 在LLM服务中应用
from common.error_handler import handle_errors
from common.retry import retry_async
from common.exceptions import LLMRequestError, LLMResponseError, RetryableError

class LLMService:
    # ...
    
    @handle_errors(reraise=True, log_level=logging.ERROR, notify=True)
    @retry_async(max_retries=3, retry_exceptions=(RetryableError, ConnectionError))
    async def generate_text(self, prompt, model_name=None, **kwargs):
        """生成文本。"""
        # 实现代码...
        try:
            # 调用LLM API
            response = await self._call_llm_api(prompt, model_name, **kwargs)
            return response
        except Exception as e:
            # 转换为自定义异常
            if isinstance(e, (ConnectionError, TimeoutError)):
                raise RetryableError(f"LLM API连接错误: {e}", retry_after=5)
            elif "rate limit" in str(e).lower():
                raise RetryableError(f"LLM API速率限制: {e}", retry_after=10)
            elif "auth" in str(e).lower() or "key" in str(e).lower():
                raise LLMAuthError(f"LLM API认证错误: {e}")
            else:
                raise LLMRequestError(f"LLM API请求错误: {e}")
```

## 3. 实施建议

### 3.1 实施步骤

1. **创建新文件**：首先创建新的异常类型文件和统一的 `LLMConfig` 类。
2. **编写测试**：为新的类和功能编写单元测试。
3. **逐步迁移**：逐步将现有代码迁移到新的架构。
4. **验证功能**：确保所有功能正常工作。
5. **清理旧代码**：移除不再使用的旧代码。

### 3.2 优先级建议

1. **高优先级**：
   - 统一 `LLMConfig` 类定义
   - 创建基本的异常类型

2. **中优先级**：
   - 实现统一的错误处理装饰器
   - 在关键服务中应用新的错误处理

3. **低优先级**：
   - 实现智能重试机制
   - 完善日志记录

### 3.3 风险评估

1. **兼容性风险**：重构可能导致现有代码不兼容。
   - **缓解措施**：添加兼容层，逐步迁移。

2. **功能中断风险**：重构过程中可能导致功能中断。
   - **缓解措施**：编写充分的测试，分阶段实施。

3. **性能影响**：增强的错误处理可能带来性能开销。
   - **缓解措施**：进行性能测试，优化关键路径。

## 4. 总结

本文档提出了 NiubiAI 系统的两个重构建议：

1. **LLMConfig 类统一定义**：解决多处定义导致的混乱问题，提高代码的可维护性。
2. **错误处理机制增强**：建立统一的错误处理框架，提高系统的稳定性和可靠性。

这些重构将使 NiubiAI 系统更加健壮、可维护，并为未来的功能扩展奠定基础。